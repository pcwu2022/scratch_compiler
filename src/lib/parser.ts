// Parser: Convert tokens to an AST (Abstract Syntax Tree)
// This class, Parser, takes an array of tokens generated by the Lexer and constructs
// an Abstract Syntax Tree (AST). The AST represents the structure of the program,
// making it easier to analyze and execute.

import { Program, BlockNode, Script, BlockType } from "@/app/types/compilerTypes";

export class Parser {
    // Array of tokens to be parsed.
    private tokens: string[];
    // Current position in the token array.
    private position: number = 0;

    // Constructor: Initializes the Parser with the token array.
    constructor(tokens: string[]) {
        this.tokens = tokens;
    }

    // parse: Main method to generate the AST (Program).
    parse(): Program {
        // Initialize the program structure with empty scripts, variables, and lists.
        const program: Program = {
            scripts: [],
            variables: new Map(),
            lists: new Map(),
        };

        // Loop through the tokens.
        while (this.position < this.tokens.length) {
            const token = this.tokens[this.position];

            // Check for script start (when event).
            if (token === 'when') {
                const script = this.parseScript();
                program.scripts.push(script);
            } else if (token === 'var') {
                // Check for variable declaration.
                this.parseVariableDeclaration(program);
            } else if (token === 'list') {
                // Check for list declaration.
                this.parseListDeclaration(program);
            } else {
                // Skip unknown tokens.
                this.position++;
            }
        }

        // Return the constructed program (AST).
        return program;
    }

    // parseScript: Parses a script (sequence of blocks).
    private parseScript(): Script {
        const blocks: BlockNode[] = [];

        // Loop until the end of the script.
        while (this.position < this.tokens.length) {
            const block = this.parseBlock();
            if (block) {
                blocks.push(block);
            } else {
                // No more blocks in the script.
                break;
            }
        }

        // Return the script with its blocks.
        return { blocks };
    }

    // parseBlock: Parses a single block.
    private parseBlock(): BlockNode | null {
        // Check if the current token is the start of a block.
        if (this.tokens[this.position] === 'when' ||
            this.tokens[this.position] === 'move' ||
            this.tokens[this.position] === 'say' ||
            this.tokens[this.position] === 'wait' ||
            this.tokens[this.position] === 'repeat' ||
            this.tokens[this.position] === 'if' ||
            this.tokens[this.position] === 'set' ||
            this.tokens[this.position] === 'change') {

            // Get the block name and move to the next token.
            const blockName = this.tokens[this.position];
            this.position++;

            // Determine the block type.
            let blockType: BlockType;

            if (blockName === 'when') blockType = 'event';
            else if (blockName === 'move') blockType = 'motion';
            else if (blockName === 'say') blockType = 'looks';
            else if (blockName === 'wait') blockType = 'control';
            else if (blockName === 'repeat' || blockName === 'if') blockType = 'control';
            else if (blockName === 'set' || blockName === 'change') blockType = 'variables';
            else blockType = 'custom';

            // Parse block arguments.
            const args: (string | number | BlockNode)[] = [];

            // Loop until the end of the block arguments or the start of the next block.
            while (this.position < this.tokens.length) {
                // Break if the next token is the start of another block.
                if (this.isBlockStart(this.tokens[this.position])) {
                    break;
                }

                // Parse nested expression in brackets.
                if (this.tokens[this.position] === '(') {
                    this.position++; // Skip '('
                    const nestedArgs: (string | number)[] = [];

                    // Loop until the closing bracket.
                    while (this.position < this.tokens.length && this.tokens[this.position] !== ')') {
                        if (this.isNumber(this.tokens[this.position])) {
                            nestedArgs.push(parseFloat(this.tokens[this.position]));
                        } else {
                            nestedArgs.push(this.tokens[this.position]);
                        }
                        this.position++;
                    }

                    if (this.position < this.tokens.length) {
                        this.position++; // Skip ')'
                    }

                    // Create a fake operator block for the nested expression.
                    args.push({
                        type: 'operators',
                        name: 'expression',
                        args: nestedArgs
                    });
                } else {
                    // Add argument (string or number).
                    if (this.isNumber(this.tokens[this.position])) {
                        args.push(parseFloat(this.tokens[this.position]));
                    } else {
                        args.push(this.tokens[this.position]);
                    }
                    this.position++;
                }
            }

            // Create the block node.
            const block: BlockNode = {
                type: blockType,
                name: blockName,
                args
            };

            // Check for next block in the sequence.
            if (this.position < this.tokens.length && this.isBlockStart(this.tokens[this.position])) {
                const nextBlock = this.parseBlock();
                if (nextBlock) {
                    block.next = nextBlock;
                }
            }

            // Return the block node.
            return block;
        }

        // Return null if not a block start.
        return null;
    }

    // parseVariableDeclaration: Parses a variable declaration.
    private parseVariableDeclaration(program: Program): void {
        this.position++; // Skip 'var'

        // Check if there's a variable name.
        if (this.position < this.tokens.length) {
            const variableName = this.tokens[this.position];
            this.position++;

            // Check for initial value assignment.
            let initialValue: any = 0;
            if (this.position < this.tokens.length && this.tokens[this.position] === '=') {
                this.position++; // Skip '='

                // Get the initial value.
                if (this.position < this.tokens.length) {
                    if (this.isNumber(this.tokens[this.position])) {
                        initialValue = parseFloat(this.tokens[this.position]);
                    } else {
                        initialValue = this.tokens[this.position].replace(/["']/g, '');
                    }
                    this.position++;
                }
            }

            // Add the variable to the program's variables map.
            program.variables.set(variableName, initialValue);
        }
    }

    // parseListDeclaration: Parses a list declaration.
    private parseListDeclaration(program: Program): void {
        this.position++; // Skip 'list'

        // Check if there's a list name.
        if (this.position < this.tokens.length) {
            const listName = this.tokens[this.position];
            this.position++;

            // Initialize an empty list.
            program.lists.set(listName, []);

            // Check for initial list values in brackets.
            if (this.position < this.tokens.length && this.tokens[this.position] === '[') {
                this.position++; // Skip '['

                const values: any[] = [];
                // Loop until the closing bracket.
                while (this.position < this.tokens.length && this.tokens[this.position] !== ']') {
                    if (this.isNumber(this.tokens[this.position])) {
                        values.push(parseFloat(this.tokens[this.position]));
                    } else {
                        values.push(this.tokens[this.position].replace(/["']/g, ''));
                    }
                    this.position++;
                }

                if (this.position < this.tokens.length) {
                    this.position++; // Skip ']'
                }

                // Update the list with initial values.
                program.lists.set(listName, values);
            }
        }
    }

    // isBlockStart: Checks if a token is the start of a block.
    private isBlockStart(token: string): boolean {
        return ['when', 'move', 'say', 'wait', 'repeat', 'if', 'set', 'change'].includes(token);
    }

    // isNumber: Checks if a value is a number.
    private isNumber(value: string): boolean {
        return !isNaN(parseFloat(value)) && isFinite(parseFloat(value));
    }
}